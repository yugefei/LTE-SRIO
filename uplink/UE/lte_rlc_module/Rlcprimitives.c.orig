#include "Rlcprimitives.h"
#include "Rlctypes.h"
#include "rlcfsm.h"
#include "../lte_system.h"

extern void  findInsBylcid(u8 lcid, void **up, void**down, RlcMode *mode);
extern FSM_PKT* rlc_UM_segment(struct UM_TX_Instance *um_tx_ins,u32 size);
extern FSM_PKT * rlc_AM_segment(struct AM_Instance *am_ins,u32 size);
extern FSM_PKT* rlc_resegment(struct AmBuffer*amBuffer, u32 retxSize);
extern void  findInsByRbid(u8 rbid,void **up, void **down , RlcMode *mode) ;  //


static void creatsubhead(FSM_PKT * skb, void **ptr, void **preptr, u8 lcid, u32 *data)
{
    struct MRLC_subHead_fif_IciMsg * subfif;
    struct MRLC_subHead_sev_IciMsg *subsev;
    fsm_printf("entering creatsubhead\n");
    if(skb->len < 128)
    {
        subsev = (MRLC_subHead_sev_IciMsg *)*ptr;
        subsev->fix.R1 = subsev->fix.R2 = 0;
        subsev->fix.E = 1;
        subsev->fix.lcid = lcid;
        subsev->fandl = skb->len;
        subsev->fandl  &= 0x7f;
        *preptr = subsev;
        *ptr = subsev+1;
        *data += 2;
        fsm_printf("the data is %d\n",  *data);
    }
    else
    {
        subfif= (MRLC_subHead_sev_IciMsg *)*ptr;
        subfif->fix.R1 = subfif->fix.R2 = 0;
        subfif->fix.E = 1;
        subfif->fix.lcid = lcid;
        subfif->fandl = skb->len;
        subfif->fandl  |= 0x8000;
//       subfif->fandl = subfif->fandl;
        *preptr = subfif;
        *ptr = subfif + 1;
        *data += 3;
        fsm_printf("the data is %d\n",  *data);
    }
}

static void check_retx_num(struct AM_Instance *amIns,int size, int *sevNum, int *fifNum)
{
    struct AmBuffer *amBuffer;
    if(!list_empty(&amIns->amRetxBuffer.list))
    {
        list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
        {
            fsm_printf("the packet's len is %d, the size is %d\n",amBuffer->pkt->len,size);
            size -= amBuffer->pkt->len;
            if(0 <= size)
            {
                if(amBuffer->pkt->len  <  128)
                    (*sevNum)++;
                else
                    (*fifNum)++;
            }
            else
            {
                if(( size + amBuffer->pkt->len + 2 ) < 128)
                    (*sevNum)++;
                else
                    (*fifNum)++;
                break;
            }
        }
    }
    FOUT;
}


static void check_stat_num(struct AM_Instance *amIns,int size, int *sevNum, int *fifNum)
{
    struct Buffer *statBuffer;
    if(!list_empty(&amIns->ctrlPduBuffer.list))
    {
        list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
        {
            fsm_printf("the packet's len is %d, the size is %d\n",statBuffer->pkt->len,size);
            size -= statBuffer->pkt->len;
            if(0 <= size)
            {
                if(statBuffer->pkt->len< 128)
                    (*sevNum)++;
                else
                    ( *fifNum)++;
            }
            else
                break;
        }
    }
    FOUT;
}

static void check_num(TM_TX_Instance * tmTxIns, int size, int *sevNum, int *fifNum )
{
    struct Buffer *txBuffer;
    if(!list_empty(&tmTxIns->tmSduBuffer.list))
    {
        list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
        {
            size -= txBuffer->pkt->len;
            fsm_printf("the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
            if(0 <= size)
            {
                if(txBuffer->pkt->len < 127)
                    (*sevNum)++;
                else
                    (*fifNum)++;
            }
            else
                break;
        }
    }
    FOUT;
}
extern bool isInsideTranWin(struct AM_Instance *amIns, SequenceNumber SN);


inline void PCRLC_CONFIG_REQ(void)
{
    CRLC_ReConfigReq_IoctrlMsg *cIoctrl = (CRLC_ReConfigReq_IoctrlMsg*)fsm_ev_data();
    //  struct list_head* pos;
    struct  AM_Instance * amIns;
    struct  UM_RX_Instance *umRxIns;
    struct  UM_TX_Instance *umTxIns;
    void *insptru,*insptrd;
    SV_PTR_GET(rlc_sv);

    findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
    fsm_printf("entering PCRLC_CONFIG_REQ\n ");
    switch(cIoctrl->mode)
    {
    case 1:                      //AM的上下行配置
        if(SV(ins_mode) == AM_MODE)
        {
            if(insptru == NULL)
                break;
            amIns = (AM_Instance *)insptru;
            fsm_printf("PCRLC_CONFIG_REQ:am instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
            amIns->reorderTimerValue= cIoctrl->amDwparas.timerReordering;
            amIns->statProhTimerValue = cIoctrl->amDwparas.timerStatusProhibit;
            amIns->pollRetxTimerValue = cIoctrl->amUpParas.timerPollRetransmit;
            amIns->pollPDU = cIoctrl->amUpParas.PollPDU;
            amIns->pollBYTE = cIoctrl->amUpParas.PollBYTE;
            amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
            break;
        }
        else
            fsm_printf("case1:there is no AM instance to be recinfiged!");
        break;

    case 2:              	 //UM的上下行配置
        if(SV(ins_mode) == UM_MODE)
        {
            if(insptru != NULL)
            {
                umTxIns = (UM_TX_Instance *)insptru;
                fsm_printf("PCRLC_CONFIG_REQ:um tran instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
                umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
            }

            umRxIns = (UM_RX_Instance *)insptrd;
            if(umRxIns == NULL)
                break;
            fsm_printf("PCRLC_CONFIG_REQ:um recv instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
            umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
            umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
        }
        else fsm_printf("case2:there is no UM  instance to be recinfiged!");
        break;

    case 3:			//UM的上行配置
        if(SV(ins_mode) ==  UM_MODE)
        {
            if(insptru == NULL)
                break;
            umTxIns = (UM_TX_Instance *)insptru;
            fsm_printf("PCRLC_CONFIG_REQ:um tran instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
            umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
        }
        else fsm_printf("case3:there is no UM TX instance to be recinfiged!");
        break;

    case 4:			//UM的下行配置
        if(SV(ins_mode) == UM_MODE)
        {
            if(insptrd == NULL)
                break;
            umRxIns = (UM_RX_Instance *)insptrd;
            fsm_printf("PCRLC_CONFIG_REQ:um recv instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
            umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
            umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
        }
        else fsm_printf("case 4:there is no UM RX instance to be recinfiged!");
        break;

    default:
        fsm_printf("wrong CRLC_CONFIG_REQ");

    }
    //  fsm_mem_free(cIoctrl);
    FOUT;
}
inline void PCRLC_BULID_REQ(void)
{
    CRLC_BuildReq_IoctrlMsg *cIoctrl = (CRLC_BuildReq_IoctrlMsg*)fsm_ev_data();
    struct  AM_Instance * amIns;
    struct  UM_RX_Instance *umRxIns;
    struct  UM_TX_Instance *umTxIns;
    int i = 0;
    SV_PTR_GET(rlc_sv);
    fsm_printf("entering PCRLC_BULID_REQ\n ");
    switch(cIoctrl->mode)
    {
    case 1:                      //AM的上下行配置
        amIns =  instance_create(struct AM_Instance);
        amIns->rbId = cIoctrl->rbIdentity;
        //fsm_printf("the rbid is %d\n", amIns->rbId);
        amIns->lcId = cIoctrl->lcIdentity;
        amIns->reorderTimerValue= cIoctrl->amDwparas.timerReordering;
        amIns->statProhTimerValue = cIoctrl->amDwparas.timerStatusProhibit;
        amIns->pollRetxTimerValue = cIoctrl->amUpParas.timerPollRetransmit;
        amIns->pollPDU = cIoctrl->amUpParas.PollPDU;
        amIns->pollBYTE = cIoctrl->amUpParas.PollBYTE;
        amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
        amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = 0;
        amIns->amRetxBufferNum = amIns->amSduBufferNum = amIns->ctrlPduBufferNum = 0;
        amIns->pollRetxTimer = amIns->reorderTimer = amIns->statProhTimer = 0;
        amIns->currentStatVar = ST_TRAN;
        //      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //根据实体地址设置定时器
        //      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
        //     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
        //分配定时器code值
        while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
        if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
        else
        {
            amIns->pollRetxTimerCode = i - 1;
            SV(allocCode[i - 1]) = -1;
        }
        while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
        if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
        else
        {
            amIns->reorderTimerCode = i - 1;
            SV(allocCode[i - 1]) = -1;
        }
        while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
        if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
        else
        {
            amIns->statProhTimerCode = i - 1;
            SV(allocCode[i - 1]) = -1;
        }
        amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
        amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
        INIT_LIST_HEAD(&amIns->amSduBuffer.list);
        INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
        INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
        INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
        INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
        for(i = 0;  i < 1024; ++i )
            amIns->amRecvWindow[i] = NULL;
        for(i = 0;  i < 1024; ++i )
            amIns->amTranWindow[i]= NULL;
        list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
        fsm_printf("PCRLC_BULID_REQ: am instance has established(rbid is %d)\n",amIns->rbId);
        break;

    case 2:              	 //UM的上下行配置
        umRxIns =  instance_create(struct UM_RX_Instance);
        umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
        umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
        umRxIns->currentStatVar = ST_TRAN;
        umRxIns->lcId = cIoctrl->lcIdentity;
        umRxIns->rbId = cIoctrl->rbIdentity;
        umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
        umRxIns->reorderTimer = 0;
        //  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
        //分配定时器code值
        while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
        if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
        else
        {
            umRxIns->reorderTimerCode = i - 1;
            SV(allocCode[i - 1]) = -1;
        }
        INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
        if(umRxIns->snFiledLength == 5)
            for(i = 0; i < 32; ++i)
                umRxIns->umRecvWindow5[i] = NULL;
        else if(umRxIns->snFiledLength == 10)
            for(i = 0; i < 1024; ++i)
                umRxIns->umRecvWindow5[i] = NULL;
        list_add_tail(&umRxIns->umRxList, &SV(vUm_rx_ins).umRxList);
        //   fsm_printf("PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);

        //上行
        umTxIns =  instance_create(UM_TX_Instance);
        umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
        umTxIns->lcid = cIoctrl->lcIdentity;
        umTxIns->rbid = cIoctrl->rbIdentity;
        umTxIns->CurrentStatVar = ST_TRAN;
        umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
        INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
        list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
        fsm_printf("PCRLC_BULID_REQ: um tran and recv instance has established(rbid is %d)\n",umTxIns->rbid);
        break;

    case 3:			//UM的上行配置
        umTxIns =  instance_create(UM_TX_Instance);
        umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
        umTxIns->lcid = cIoctrl->lcIdentity;
        umTxIns->rbid = cIoctrl->rbIdentity;
        umTxIns->CurrentStatVar = ST_TRAN;
        umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
        INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
        list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
        fsm_printf("PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",umTxIns->rbid);
        break;

    case 4:			//UM的下行配置
        umRxIns =  instance_create(struct UM_RX_Instance);
        umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
        umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
        umRxIns->currentStatVar = ST_TRAN;
        umRxIns->lcId = cIoctrl->lcIdentity;
        umRxIns->rbId = cIoctrl->rbIdentity;
        umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
        umRxIns->reorderTimer = 0;
        //  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
        //分配定时器code值
        while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
        if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
        else
        {
            umRxIns->reorderTimerCode = i - 1;
            SV(allocCode[i - 1]) = -1;
        }
        INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
        if(umRxIns->snFiledLength == 5)
            for(i = 0; i < 32; ++i)
                umRxIns->umRecvWindow5[i] = NULL;
        else if(umRxIns->snFiledLength == 10)
            for(i = 0; i < 1024; ++i)
                umRxIns->umRecvWindow5[i] = NULL;
        list_add_tail(&umRxIns->umRxList, &SV(vUm_rx_ins).umRxList);
        fsm_printf("PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);
        break;

    default:
        fsm_printf("wrong CRLC_BULID_REQ");

    }
    // fsm_mem_free(cIoctrl);
    FOUT;
}
inline void PCRLC_DEACT_REQ(void)
{
    CRLC_DeactReq_IoctrlMsg *cIoctrl;
    struct  AM_Instance *amIns;
    struct  UM_RX_Instance *umRxIns;
    struct  UM_TX_Instance *umTxIns;
    struct AmSduBuffer*amsBuffer, *tempAmsBuffer;
    struct AmBuffer *amBuffer, *tempAmBuffer;
    struct Buffer *buffer, *tempBuffer;
    struct UmBuffer *umBuffer, *tempUmBuffer;
    void *insptru, *insptrd;
    SV_PTR_GET(rlc_sv);
    cIoctrl = (CRLC_DeactReq_IoctrlMsg*)fsm_ev_data();
    findInsByRbid(cIoctrl->rbIdentity,&insptru, &insptrd , &SV(ins_mode));
    fsm_printf("entering PCRLC_DEACT_REQ\n");
    switch(SV(ins_mode))
    {
    case UM_MODE:
        if(insptrd != NULL)
        {
            umRxIns = (UM_RX_Instance *)insptrd;
            //将UM接收侧实体从链表中删除
            list_del(&umRxIns->umRxList);
            fsm_printf("PCRLC_DEACT_REQ:um recv instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
            //释放接收队列
            if(!list_empty(&umRxIns->umRecvBuffer.list))
            {
                list_for_each_entry_safe(umBuffer,tempUmBuffer, &umRxIns->umRecvBuffer.list,list)
                {
                    list_del(&umBuffer->list);
                    //回收定时器code值
                    SV(allocCode[umRxIns->reorderTimerCode]) = umRxIns->reorderTimerCode;
                    fsm_pkt_destroy(umBuffer->pkt);
                    fsm_mem_free(umBuffer);
                    if(list_empty(&umRxIns->umRecvBuffer.list))
                        break;
                }
            }
            //释放UM接收侧实体
            fsm_mem_free(umRxIns);
        }
        if(insptru == NULL)
            break;
        umTxIns = (UM_TX_Instance *)insptru;

        //将UM发送侧实体从链表中删除
        list_del(&umTxIns->umTxList);
        fsm_printf("PCRLC_DEACT_REQ:um tran instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
        //释放UM发送侧的新数据队列
        if(!list_empty(&umTxIns->umSduBuffer.list))
        {
            list_for_each_entry_safe(umBuffer,tempUmBuffer, &umTxIns->umSduBuffer.list,list)
            {
                list_del(&umBuffer->list);
                fsm_pkt_destroy(umBuffer->pkt);
                fsm_mem_free(umBuffer);
                if(list_empty(&umTxIns->umSduBuffer.list))
                    break;
            }
        }
        //释放UM发送侧实体
        fsm_mem_free(umTxIns);
        break;
    case AM_MODE:
        amIns = (AM_Instance *)insptru;
        if(amIns == NULL)
            break;
        //将AM实体从队列中删除
        list_del(&amIns->amList);
        fsm_printf("PCRLC_DEACT_REQ:am instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
        //回收定时器code值
        SV(allocCode[amIns->pollRetxTimerCode]) = amIns->pollRetxTimerCode;
        SV(allocCode[amIns->reorderTimerCode]) = amIns->reorderTimerCode;
        SV(allocCode[amIns->statProhTimerCode]) = amIns->statProhTimerCode;
        //释放重传队列
        if(!list_empty(&amIns->amRetxBuffer.list))
        {
            list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
            {
                list_del(&amBuffer->list);
                fsm_pkt_destroy(amBuffer->pkt);
                fsm_mem_free(amBuffer);
                if(list_empty(&amIns->amRetxBuffer.list))
                    break;
            }
        }
        //释放已发送队列
        if(!list_empty(&amIns->amTransmittedBuffer.list))
        {
            list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
            {
                list_del(&amBuffer->list);
                fsm_pkt_destroy(amBuffer->pkt);
                fsm_mem_free(amBuffer);
                if(list_empty(&amIns->amTransmittedBuffer.list))
                    break;
            }
        }
        //释放新数据队列
        if(!list_empty(&amIns->amSduBuffer.list))
        {
            list_for_each_entry_safe(amsBuffer,tempAmsBuffer, &amIns->amSduBuffer.list,list)
            {
                list_del(&amsBuffer->list);
                fsm_pkt_destroy(amsBuffer->pkt);
                fsm_mem_free(amsBuffer);
                if(list_empty(&amIns->amSduBuffer.list))
                    break;
            }
        }
        //释放控制数据队列
        if(!list_empty(&amIns->ctrlPduBuffer.list))
        {
            list_for_each_entry_safe(buffer,tempBuffer, &amIns->ctrlPduBuffer.list,list)
            {
                list_del(&buffer->list);
                fsm_pkt_destroy(buffer->pkt);
                fsm_mem_free(buffer);
                if(list_empty(&amIns->ctrlPduBuffer.list))
                    break;
            }
        }
        //释放接收数据队列
        if(!list_empty(&amIns->amRecvBuffer.list))
        {
            list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
            {
                list_del(&amBuffer->list);
                fsm_pkt_destroy(amBuffer->pkt);
                fsm_mem_free(amBuffer);
                if(list_empty(&amIns->amRecvBuffer.list))
                    break;
            }
        }
        //释放AM实体
        fsm_mem_free(amIns);
        break;
    default:
        fsm_printf(" PCRLC_DEACT_REQ:cannot distinguish the instance to distinguish.\n");
    }
    // fsm_mem_free(cIoctrl);
    FOUT;
}
inline void PCRLC_SUSPEND_REQ(void)
{
    CRLC_SuspendReq_IoctrlMsg *cIoctrl = (CRLC_SuspendReq_IoctrlMsg*) fsm_ev_data();
    struct  AM_Instance * amIns;
    struct  UM_RX_Instance *umRxIns;
    struct  UM_TX_Instance *umTxIns;
    void *insptru, *insptrd;
    SV_PTR_GET(rlc_sv);
    findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    fsm_printf("entering PCRLC_SUSPEND_REQ(SV(ins_mode) is %d,cIoctrl->rbIdentity is %d)\n",SV(ins_mode),cIoctrl->rbIdentity);
    switch(SV(ins_mode))
    {
    case UM_MODE:
        if(insptrd != NULL)
        {
            umRxIns = (UM_RX_Instance *)insptrd;

            umRxIns->currentStatVar = ST_SUSPEND;
            fsm_printf("PCRLC_SUSPEND_REQ:um recv instance has suspended (rbid is %d)\n", umRxIns->rbId);
            if(umRxIns->reorderTimer)
            {
                fsm_schedule_cancel(umRxIns->reorderTimer);
                umRxIns->reorderTimer = 0;
            }
        }
        if(insptru == NULL)
            break;
        umTxIns = (UM_TX_Instance *)insptru;
        umTxIns->CurrentStatVar = ST_SUSPEND;
        fsm_printf("PCRLC_SUSPEND_REQ:um tran instance has suspended (rbid is %d)\n", umTxIns->rbid);
        break;

    case AM_MODE:
        if(insptru == NULL)
            break;
        amIns =  (AM_Instance * )insptru;
        amIns->currentStatVar = ST_SUSPEND;
        fsm_printf("PCRLC_SUSPEND_REQ:am instance has suspended (rbid is %d)\n", amIns->rbId);
        if(amIns->pollRetxTimer)
        {
            fsm_schedule_cancel(amIns->pollRetxTimer);
            amIns->pollRetxTimer = 0;
        }
        if(amIns->reorderTimer)
        {
            fsm_schedule_cancel(amIns->reorderTimer);
            amIns->reorderTimer = 0;
        }
        if(amIns->statProhTimer)
        {
            fsm_schedule_cancel(amIns->statProhTimer);
            amIns->statProhTimer = 0;
        }
        break;
    default:
        fsm_printf("PCRLC_SUSPEND_REQ:cannot distinguish the instance \n");
    }

    //  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
    //fsm_mem_free(cIoctrl);
    FOUT;
}

inline void PCRLC_RESUME_REQ(void)
{
    CRLC_ResumeReq_IoctrlMsg *cIoctrl = (CRLC_ResumeReq_IoctrlMsg*) fsm_ev_data();
    struct  AM_Instance * amIns;
    struct  UM_RX_Instance *umRxIns;
    struct  UM_TX_Instance *umTxIns;
    void * insptru,*insptrd;
    SV_PTR_GET(rlc_sv);
    findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    fsm_printf("entering PCRLC_RESUME_REQ\n");
    switch(SV(ins_mode))
    {
    case UM_MODE:
        if(insptrd == NULL)
            break;
        umRxIns = ( UM_RX_Instance *)insptrd;
        umRxIns->currentStatVar = ST_TRAN;
        fsm_printf("PCRLC_RESUME_REQ:um recv instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);

        if(insptru == NULL)
            break;
        umTxIns = ( UM_TX_Instance *)insptru;
        umTxIns->CurrentStatVar = ST_TRAN;
        fsm_printf("PCRLC_RESUME_REQ:um tran instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
        break;

    case AM_MODE:
        if(insptru == NULL)
            break;
        amIns = (AM_Instance *)insptru;
        amIns->currentStatVar = ST_TRAN;
        fsm_printf("PCRLC_RESUME_REQ:am instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
        break;
    default:
        fsm_printf("  ");
    }
//   fsm_mem_free(cIoctrl);
    FOUT;
}
inline void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
    CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
    cioctrl->eventCode = evCode;
    cioctrl->rbIdentity = rbid;
    fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND,( void * )cioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
    fsm_mem_free(cioctrl);
    FOUT;
}

inline void PPRLC_DISC_REQ(void)  {}
/****
接收传输机会并打包传输机会中指示的实体中的数据，传输给mac层
***/
inline void PMRLC_TRANSOP_IND (void)
{
    MRLC_TransOp_IoctrlMsg *mIoctrl;
    unsigned int subhead, controlelm, data, sevNum,  fifNum;
    struct  AM_Instance * amIns;
    struct  UM_TX_Instance *umTxIns;
    struct  TM_TX_Instance *tmTxIns;
    void *insptru, *insptrd, *head, *ptr, *preptr;
    FSM_PKT* pkptr, *pkp;
    struct AmBuffer *amBuffer;
    struct Buffer *buffer, *tempb;
    struct	MRLC_subHead_fix_IciMsg *fix;
    struct MRLC_toMac_IciMsg *icimsg;
    u16 *nump,num;
    u32 size = 0;     //the total size in a buffer to transimit
    SV_PTR_GET(rlc_sv);

    nump = (u16*)fsm_ev_data();
    if((nump == NULL)||((num = *nump) == 0))
        FOUT;
    /* 根据传输机会中提供的数据大小，按最大需求计数数据包子头的大小*/
    fsm_printf("entering PMRLC_TRANSOP_IND(number of instances is %d)\n", num);
    mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
    subhead = data = sevNum = fifNum = 0;
    controlelm = 14 + 10;
    while(num > 0)
    {
        fsm_printf("number %d:\n", num);
        findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
        fsm_printf("the instance mode is %d\n", SV(ins_mode));
        switch(SV(ins_mode))
        {
        case TM_MODE:
            if(insptru == NULL)
                break;
            tmTxIns = (TM_TX_Instance *)insptru;
            data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
            sevNum = fifNum = 0;
            check_num(tmTxIns, mIoctrl->txQueueSize,  &sevNum,  &fifNum);
            subhead += 2*sevNum + 3*fifNum;
            fsm_printf("tm instance has %d 7bits sunhead,and %d 15bits\n", sevNum, fifNum);
            break;

        case UM_MODE:
            if(insptru == NULL)
                break;
            umTxIns = (UM_TX_Instance *)insptru;
            data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
            fsm_printf("the data is %d\n", data);
            if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
                subhead += 2;
            else
                subhead += 3;
            fsm_printf("um instance(lcid is %d)'s buffer's subhead is %d \n",umTxIns->lcid,subhead);
            break;

        case AM_MODE:
            if(insptru == NULL)
                break;
            amIns  = (AM_Instance * )insptru;
            data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
                    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;
            sevNum = fifNum = 0;
            check_retx_num(amIns,mIoctrl->retxQueueSize,  &sevNum,  &fifNum);
            subhead += 2*sevNum + 3*fifNum;
            fsm_printf("am instance(lcid is %d)'s retx buffer has %d 7bits sunhead,and %d 15bits\n",amIns->lcId,sevNum, fifNum);

            sevNum = fifNum = 0;
            check_stat_num(amIns,mIoctrl->statusPduSize, &sevNum, &fifNum);
            subhead += 2*sevNum + 3*fifNum;
            fsm_printf("am instance(lcid is %d)'s status buffer has %d 7bits sunhead,and %d 15bits\n",amIns->lcId,sevNum, fifNum);

            if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) > 127)
                subhead += 3;
            else
                subhead += 2;
            fsm_printf("am instance(lcid is %d)'s buffer's subhead is %d \n",amIns->lcId,subhead);
            break;

        default:
            fsm_printf("cannot find the instance\n");
        }
        ++mIoctrl;
        --num;
    }
    fsm_printf("the size of the subhead is %d\n", subhead);
    /* 根据计算出的大小建立SKB，并申请一块内存，保存ICI信息*/
    pkptr = fsm_pkt_create( subhead + data + controlelm + sizeof(MRLC_toMac_IciMsg));
    head = preptr =  fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //暂时保存ici信息的内存区域,preptr用于在最后一个子头修改E域
    fsm_skb_reserve(pkptr, subhead + controlelm + sizeof(MRLC_toMac_IciMsg));
    icimsg = (MRLC_toMac_IciMsg*)head;
    ptr = icimsg + 1;   //填充子头的指针
    data = 0;     //计数实际封装包的总共的子头的大小
    /* 将PDU数据装入申请的SKB 中*/
    mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
    num = *nump;
    while(num > 0)
    {
        fsm_printf("number %d:\n", num);
        findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
        switch(SV(ins_mode))
        {
        case TM_MODE:
            if(insptru == NULL)
                break;
            tmTxIns = (TM_TX_Instance *)insptru;
            if(!list_empty(&tmTxIns->tmSduBuffer.list))
            {
                list_for_each_entry_safe(buffer, tempb, &tmTxIns->tmSduBuffer.list,list)
                {
                    if(buffer->pkt->len  >  mIoctrl->txQueueSize)
                    {
                        fsm_printf("break:tm instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len);
                        break;
                    }
                    else
                    {
                        list_del(&buffer->list);
                        fsm_mem_cpy(pkptr->tail,  buffer->pkt->data, buffer->pkt->len);
                        fsm_skb_put(pkptr, buffer->pkt->len);
                        mIoctrl->txQueueSize -= buffer->pkt->len;
                        creatsubhead(buffer->pkt,  &ptr, &preptr, tmTxIns->lcId, &data);
                        fsm_printf("tm instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len);
                        if(list_empty(&tmTxIns->tmSduBuffer.list))
                            break;
                    }
                }
            }
            break;

        case UM_MODE:
            if(insptru == NULL)
                break;
            umTxIns = (UM_TX_Instance *)insptru;
            pkp = rlc_UM_segment(umTxIns , mIoctrl->txQueueSize);
            fsm_mem_cpy( pkptr->tail, pkp->data, pkp->len);
            fsm_skb_put( pkptr,pkp->len);
            creatsubhead(pkp, &ptr,  &preptr, umTxIns->lcid, &data);
            fsm_printf("um instance data is %d\n", data);
            break;

        case AM_MODE:
            if(insptru == NULL)
                break;
            amIns  = (AM_Instance * )insptru;
            //传输新数据
            if(isInsideTranWin(amIns,amIns->SN) &&((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) > 0))
            {
                pkp = rlc_AM_segment( amIns, mIoctrl->txQueueSize + mIoctrl->txQueueHeader);
                fsm_mem_cpy( pkptr->tail, pkp->data, pkp->len);
                fsm_skb_put( pkptr,pkp->len);
                creatsubhead(pkp, & ptr,  &preptr, amIns->lcId, &data);
                ++amIns->vt_s ;
                fsm_printf("amIns->vt_s  is updated to %d, the len of the data is %d\n",amIns->vt_s , pkp->len);
            }
            //传输重传PDU
            size  = mIoctrl->retxQueueSize +mIoctrl->retxQueueHeader;
                if(!list_empty(&amIns->amRetxBuffer.list))
                {
                    list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
                    {
                        if(isInsideTranWin(amIns,amBuffer->SN) && (size > 0) )
                        {
                            pkp =  rlc_resegment( amBuffer, size);
                            fsm_mem_cpy( pkptr->tail,  pkp->data, pkp->len);
                            fsm_skb_put( pkptr,pkp->len);
                            size  -= pkp->len;
                            creatsubhead(pkp, &ptr, & preptr, amIns->lcId,& data);
                            fsm_printf("am instance mIoctrl->retxQueueSize is %d, data is %d\n", mIoctrl->retxQueueSize, pkp->len);
                            if(list_empty(&amIns->amRetxBuffer.list))
                                break;
                        }
                    }
                }        
            //传输状态PDU

                if(!list_empty(& amIns->ctrlPduBuffer.list))
                {
                    list_for_each_entry_safe(buffer, tempb,& amIns->ctrlPduBuffer.list,list )
                    {
                        if(buffer->pkt->len > mIoctrl->statusPduSize)
                            break;
                        else
                        {
                            list_del(&buffer->list);
                            fsm_mem_cpy(pkptr->tail,  buffer->pkt->data, buffer->pkt->len);
                            fsm_skb_put(pkptr, buffer->pkt->len);
                            mIoctrl->statusPduSize -= buffer->pkt->len;
                            creatsubhead(buffer->pkt, & ptr,  &preptr, amIns->lcId , & data);
                            fsm_printf("am instance mIoctrl->statusPduSize is %d, data is %d\n", mIoctrl->statusPduSize, buffer->pkt->len);
                            if(list_empty(&amIns->ctrlPduBuffer.list))
                                break;
                        }
                    }
            }
            break;

        default:
            fsm_printf("cannot find the instance\n");
        }
        ++mIoctrl;
        --num;
    }

    fix = (MRLC_subHead_fix_IciMsg *)preptr;
    fix->E = 0;    //将最后一个子头的E域改为0
    icimsg->len = data;
    icimsg->rnti = 0;
    fsm_mem_cpy(pkptr->head, head,  data + sizeof(MRLC_toMac_IciMsg));
    fsm_mem_free(head);
    fsm_pkt_send( pkptr, STRM_TO_MAC);
    SV(isBufferReq) = 0;
    FOUT;
}


inline void PMRLC_BUFFERREP_REQ(void)
{
    MRLC_ReportReq_IoctrlMsg *mioctrl;
    void *mhead;
    struct list_head* pos;
    u16 num = 0,*nump;                              //需要发送的结构体个数
    struct  AM_Instance * amIns;
    struct  UM_TX_Instance *umTxIns;
    struct  TM_TX_Instance *tmTxIns;
    SV_PTR_GET(rlc_sv);
//计数需要发送的数据大小
    if (!list_empty(&SV(vAm_ins).amList))
    {
        list_for_each(pos,&SV(vAm_ins).amList)
        {
            amIns = list_entry(pos,struct AM_Instance,amList);
            if(amIns->amSduBufferSize != 0 || amIns->amRetxBufferSize != 0 || amIns->ctrlPduBufferSize != 0)
            {
                fsm_printf("am instance (rbid is %d) has data to report\n", amIns->rbId);
                num++;
            }
        }
    }

    if (!list_empty(&SV(vUm_tx_ins).umTxList))
    {
        list_for_each(pos,&SV(vUm_tx_ins).umTxList)
        {
            umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
            if(umTxIns->umSduBufferSize != 0)
            {
                fsm_printf("um instance (rbid is %d) has data to report\n", umTxIns->rbid);
                num++;
            }
        }
    }
    if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    {
        list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
        {
            tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
            if(tmTxIns->tmSduBufferSize != 0)
            {
                fsm_printf("tm instance (rbid is %d) has data to report\n", tmTxIns->rbId);
                num++;
            }
        }
    }
//分配空间大小
    mhead =  fsm_mem_alloc(2 + sizeof(MRLC_ReportReq_IoctrlMsg)*num);
    nump = (u16 *)mhead;
    *nump = num;
    mioctrl = (MRLC_ReportReq_IoctrlMsg*)(++nump);
//填充分配的内存空间
    if (!list_empty(&SV(vAm_ins).amList))
    {
        list_for_each(pos,&SV(vAm_ins).amList)
        {
            amIns = list_entry(pos,struct AM_Instance,amList);
            if(amIns->amSduBufferSize != 0 || amIns->amRetxBufferSize != 0 || amIns->ctrlPduBufferSize != 0)
            {
                mioctrl->rnti = 0;
                mioctrl->lcid = amIns->lcId;
                mioctrl->txQueueSize = amIns->amSduBufferSize;
                mioctrl->txQueueHeader = 2 + 2* amIns->amSduBufferNum;
                mioctrl->retxQueueSize = amIns->amRetxBufferSize;
                mioctrl->retxQueueHeader = 2*amIns->amRetxBufferNum;
                mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
                mioctrl->statusPduHeader =  0;
                fsm_printf("the total size is %d(lcid is %d)\n", mioctrl->txQueueSize + mioctrl->retxQueueSize + mioctrl->statusPduSize + mioctrl->statusPduHeader + \
                           mioctrl->txQueueHeader  + mioctrl->retxQueueHeader, mioctrl->lcid);
                ++mioctrl;
            }
        }
    }

    if (!list_empty(&SV(vUm_tx_ins).umTxList))
    {
        list_for_each(pos,&SV(vUm_tx_ins).umTxList)
        {
            umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
            if(umTxIns->umSduBufferSize != 0)
            {
                mioctrl->rnti = 0;
                mioctrl->lcid = umTxIns->lcid;
                mioctrl->txQueueSize = umTxIns->umSduBufferSize;
                mioctrl->retxQueueSize = 0;
                mioctrl->retxQueueHeader = 0;
                mioctrl->statusPduSize = 0;
                mioctrl->statusPduHeader = 0;

                if(umTxIns->snFiledLength == 5)
                {
                    mioctrl->txQueueHeader = 1 + 2*umTxIns->umSduBufferNum;
                }
                if(umTxIns->snFiledLength == 10)
                {
                    mioctrl->txQueueHeader =2 + 2*umTxIns->umSduBufferNum;
                }
                fsm_printf("the total size is %d(lcid is %d)\n", mioctrl->txQueueSize  + mioctrl->txQueueHeader, mioctrl->lcid);
            }
        }
    }
    if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    {
        list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
        {
            tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
            if(tmTxIns->tmSduBufferSize != 0)
            {
                mioctrl->rnti = 0;
                mioctrl->lcid = tmTxIns->lcId;
                mioctrl->txQueueSize = umTxIns->umSduBufferSize;
                mioctrl->txQueueHeader = 0;
                mioctrl->retxQueueSize = 0;
                mioctrl->statusPduSize = 0;
                mioctrl->statusPduHeader = 0;
                mioctrl->retxQueueHeader = 0;
                fsm_printf("the total size is %d(lcid is %d)\n", mioctrl->txQueueSize, mioctrl->lcid);
                ++mioctrl;
            }
        }
    }
    if(num)
    {
        fsm_printf("the num of instances to report is %d, and the space is %d\n", num, 2 + sizeof(MRLC_ReportReq_IoctrlMsg)*num );
        fsm_do_ioctrl(STRM_TO_MAC, MRLC_BUFREPORT_REQ, mhead, 2 + sizeof(MRLC_ReportReq_IoctrlMsg)*num);
        fsm_mem_free(mhead);
        SV(isBufferReq) = 1;
    }
    FOUT;
}

/*
inline void PMRLC_BUFFERREP_REQ(void)
{
    MRLC_ReportReq_IoctrlMsg *mioctrl, *mhead, init, *mpos,*temp;
    struct list_head* pos;
    unsigned int len;
    struct  AM_Instance * amIns;
    struct  UM_TX_Instance *umTxIns;
    struct  TM_TX_Instance *tmTxIns;
    FIN(rlc_bufreport());
    SV_PTR_GET(rlc_sv);
    len = 0;
    mhead = mioctrl = &init;
    INIT_LIST_HEAD(&mioctrl->next);
    fsm_printf("entering PMRLC_BUFFERREP_REQ\n");
//   INIT_LIST_HEAD(&mhead->next);
    if (!list_empty(&SV(vAm_ins).amList))
    {
        list_for_each(pos,&SV(vAm_ins).amList)
        {
            amIns = list_entry(pos,struct AM_Instance,amList);
            if(amIns->amSduBufferSize != 0 && amIns->amRetxBufferSize != 0 && amIns->ctrlPduBufferSize != 0)
            {
              fsm_printf("am instance (rbid is %d) has data to report\n", amIns->rbid);
                mioctrl = (MRLC_ReportReq_IoctrlMsg*)fsm_mem_alloc(sizeof(MRLC_ReportReq_IoctrlMsg));
                len += sizeof(MRLC_ReportReq_IoctrlMsg);
                //mioctrl->frame = 0;
                //mioctrl->subframe = 0;
                mioctrl->rnti = 0;
                mioctrl->lcid = amIns->lcId;
                mioctrl->txQueueSize = amIns->amSduBufferSize;
                mioctrl->retxQueueSize = amIns->amRetxBufferSize;
                mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
                mioctrl->statusPduHeader =  2;

                if(amIns->amSduBufferNum == 1)
                    mioctrl->txQueueHeader =  2;
                else if(amIns->amSduBufferNum % 2 == 0)
                    mioctrl->txQueueHeader =( 8 + amIns->amSduBufferNum * 12 + 16)/8;
                else
                    mioctrl->txQueueHeader = (8 + amIns->amSduBufferNum * 12 + 20)/8;

                if(amIns->amRetxBufferNum == 1)
                    mioctrl->retxQueueHeader =  4;
                else if(amIns->amRetxBufferNum % 2 == 0)
                    mioctrl->retxQueueHeader = (8 + amIns->amRetxBufferNum * 12 + 32)/8;
                else
                    mioctrl->retxQueueHeader =( 8 + amIns->amRetxBufferNum * 12 + 36) /8;
                list_add_tail(&mioctrl->next, &mhead->next);

            }
        }
    }

    if (!list_empty(&SV(vUm_tx_ins).umTxList))
    {
        list_for_each(pos,&SV(vUm_tx_ins).umTxList)
        {
            umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
            if(umTxIns->umSduBufferSize != 0)
            {
             fsm_printf("um instance (rbid is %d) has data to report\n", umTxIns->rbid);
                mioctrl = (MRLC_ReportReq_IoctrlMsg*)fsm_mem_alloc(sizeof(MRLC_ReportReq_IoctrlMsg));
                len += sizeof(MRLC_ReportReq_IoctrlMsg);
                //mioctrl->frame = 0;
                //mioctrl->subframe = 0;
                mioctrl->rnti = 0;
                mioctrl->lcid = umTxIns->lcid;
                mioctrl->txQueueSize = umTxIns->umSduBufferSize;
                mioctrl->retxQueueSize = 0;
                mioctrl->statusPduSize = 0;
                mioctrl->statusPduHeader = 0;
                mioctrl->retxQueueHeader = 0;

                if(umTxIns->snFiledLength == 5)
                {
                    if(umTxIns->umSduBufferNum == 1)
                        mioctrl->txQueueHeader = 1;
                    else if(umTxIns->umSduBufferNum % 2 == 0)
                        mioctrl->txQueueHeader = (umTxIns->umSduBufferNum * 12 + 16) /8;
                    else
                        mioctrl->txQueueHeader = (umTxIns->umSduBufferNum * 12 + 20) /8;
                }
                if(umTxIns->snFiledLength == 10)
                {
                    if(umTxIns->umSduBufferNum == 1)
                        mioctrl->txQueueHeader = 2;
                    else if(umTxIns->umSduBufferNum % 2 == 0)
                        mioctrl->txQueueHeader =( 8 + umTxIns->umSduBufferNum * 12 + 16)/8;
                    else
                        mioctrl->txQueueHeader =( 8+ umTxIns->umSduBufferNum * 12 + 20) /8;
                }

                list_add_tail(&mioctrl->next, &mhead->next);
            }
        }
    }
    if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    {
        list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
        {
            tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
            if(tmTxIns->tmSduBufferSize != 0)
            {
                mioctrl = (MRLC_ReportReq_IoctrlMsg*)fsm_mem_alloc(sizeof(MRLC_ReportReq_IoctrlMsg));
                len += sizeof(MRLC_ReportReq_IoctrlMsg);
                //mioctrl->frame = 0;
                //mioctrl->subframe = 0;
                mioctrl->rnti = 0;
                mioctrl->lcid = tmTxIns->lcId;
                mioctrl->txQueueSize = umTxIns->umSduBufferSize;
                mioctrl->txQueueHeader = 0;
                mioctrl->retxQueueSize = 0;
                mioctrl->statusPduSize = 0;
                mioctrl->statusPduHeader = 0;
                mioctrl->retxQueueHeader = 0;
                list_add_tail(&mioctrl->next, &mhead->next);
            }
        }
    }
    if(len)
    {
        fsm_printf("the len to report is %d\n", len);
        fsm_do_ioctrl(STRM_TO_MAC, MRLC_BUFREPORT_REQ, (void*)mhead, sizeof(MRLC_ReportReq_IoctrlMsg));
        if(!list_empty(&mhead->next))
        {
            list_for_each_entry_safe(mpos,temp, &mhead->next,next)
            {
                list_del( &mpos->next);
                fsm_mem_free(mpos);
                if(list_empty(&mhead->next))
                    break;
            }
        }
        SV(isBufferReq) = 1;
    }

    FOUT;
}

*/
